# 오답노트

## 1. [9996번 - 한국이 그리울 땐 서버에 접속하지](https://www.acmicpc.net/problem/9996) 
###  1) 문제설명


주어진 패턴과 입력값을 일치하게 만들어야한다. 패턴에는 무조건 하나의 * 문자가 들어있고 * 문자 기준으로 양옆에는 항상 소문자가 존재하며 문자열의 길이는 100을 넘지않는다.  * 를 기준으로 양옆의 시작문자열과 끝 문자열이 일치한다면 가운에는 어떤 문자열이 와도 대치될 수 있다.

```
ex. 
패턴: a*b
입력값: acdb
```

### 2) 접근방식
- 주어진 패턴 문자열을 * 기준으로 두개의 `string[]` 으로 나누어 비교한다.
  ```java
   String[] pattern = br.readLine().split("\\*");
  ```
- 첫 문자열부터 일치하지 않으면 바로 "NE" 를 출력한다.
- 두개의 문자열로 나눈 패턴 중 1번째 패턴을 입력 문자열에서 일치하는지 비교하고 일치한 문자열의 마지막 index 를 알아내서 다음 두번째 패턴 문자열과 일치하는지 비교한다.
   - `String.contains()`, `String.substring()` 등을 사용했다.

### 3) 틀린 이유
- * 을 기준으로 나눈 두개의 문자열이 무조건 맨앞, 맨뒤에 존재 해야한다.
- 따라서 패턴 문자열에서 * 을 뺀 length 보다 입력 문자열의 length 가 작다면 무조건 "NE" 를 출력해야했다.
- 위 조건을 알아낸 후 length 비교 조건을 넣었는데 실제 패턴 문자열 전체의 크기가 아닌 * 을 기준으로 split 된 문자열의 개수를 반환했기 때문에 틀렸다.
   ```java
      input.length() >= pattern.length // pattern.length 는 무조건 2만 반환되고 있었음
   ```

### 4) 올바른 접근 방식 및 해결 방식
- `*` 을 기준으로 나눈 두개의 문자열이 무조건 맨 앞, 맨 뒤에 존재한다는 것을 먼저 캐치해야 한다. 따라서 아래와 같은 코드를 이용할 수 있다.
   ```java
      input.startsWith(pattern[0]) && input.endsWith(pattern[1])
   ```
  
### 5) 최종 코드
```java
public class BG_9996 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        var n = Integer.parseInt(br.readLine());
        String pattern = br.readLine();
        String[] patternArray = pattern.split("\\*");

        for(int i = 0; i< n; i ++) {
            String input = br.readLine();
            if(input.startsWith(patternArray[0]) && input.endsWith(patternArray[1]) && input.length() >= pattern.length()-1) {
                System.out.println("DA");
            } else {
                System.out.println("NE");
            }
        }
    }
}
```